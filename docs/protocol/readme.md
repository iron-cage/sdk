# Protocol Collection

Communication protocols defining message formats, wire protocols, and version compatibility.

---

## Directory Responsibilities

| ID | Entity | Responsibility |
|----|--------|----------------|
| 002 | **002_rest_api_protocol.md** | Define cross-cutting REST API standards and master index for 23 Control Panel resources across 5 categories (Entity CRUD 6, Operation RPC-style 4, Analytics derived 8, Configuration admin-only 3, System public 2). Establish 5 universal standards: Audit Logging (mutations POST/PUT/DELETE with timestamp/user_id/action/resource_type/resource_id/changes, 90-day retention), CLI-API Parity (100% coverage 69 commands: 47 control + 22 token mapping to endpoints), System Resources (health /api/health 200/503, version /api/version public), Rate Limiting (auth 10/min, mutations 100/hour, reads 1000/hour, analytics 500/hour, admin unlimited), Example Data (canonical agent_a1b2c3d4, token_t9x8y7z6, user_u5v6w7x8 values). Reference 4 external standards (Pagination/Sorting/Filtering, Error Format, ID Format, Data Format via Standards docs). Document 3 authentication patterns (IC Token JWT agent auth Bearer ic_..., User Token JWT dashboard Bearer ..., None public). Provide Complete Protocol Reference table mapping resources to Protocol 006-017 with certainty classification (Certain/MUST-HAVE/NICE-TO-HAVE/POST-PILOT) |
| 003 | **003_websocket_protocol.md** | Define real-time WebSocket protocol for dashboard monitoring enabling sub-100ms latency push notifications of agent execution state changes, LLM operation tracking, and budget safety alerts. Specify 4 message types with JSON type discriminator format: STATE_UPDATE (agent running/idle/error state with current_lead progress and budget_spent tracking), AGENT_EVENT (LLM calls and tool invocations with model gpt-4, tokens 500, cost_usd 0.015 details), COST_ALERT (budget threshold warnings with severity warning/critical and percentage 90-100 consumed), HEARTBEAT (30-second keepalive preventing 60-second disconnect timeout). Document 5-step connection lifecycle (connect ws://localhost:8080/ws â†’ authenticate IC Token first message â†’ subscribe all agent events â†’ receive server heartbeats â†’ disconnect on timeout) with automatic exponential backoff reconnection strategy (1s initial retry, maximum 30s, resume from last known state). Eliminate HTTP polling inefficiencies (98% server load reduction from 60 req/min constant polling, sub-100ms vs 1-5s latency delay). Adhere to ID Format Standards (agent_<uuid>), Data Format Standards (ISO 8601 timestamps, decimal currency), Error Format Standards (connection failures). Complement REST API (002) request/response pattern with bidirectional persistent connection for time-sensitive operator intervention events (budget exhaustion, agent errors requiring pause within seconds) |
| 004 | **004_mcp_integration_protocol.md** | [POST-PILOT] Define Model Context Protocol (MCP) integration enabling AI agents to discover and invoke tools through standard JSON-RPC 2.0 based wire protocol while adding Iron Cage governance layer for budget tracking, safety validation, and authorization enforcement. Specify 2 core MCP methods: tools/list (discovery returning tool array with name read_file, description, inputSchema object/properties/required fields for dynamic capability detection), tools/call (invocation accepting name, arguments params returning content array results). Document Iron Cage 7-step governance flow wrapping each tool invocation: (1) agent calls MCP tool via proxy, (2) validate tool authorization against agent permissions, (3) check budget before invocation preventing $10 limit breach, (4) invoke actual MCP tool with original params, (5) scan result for PII before returning, (6) track cost $0.015 per call against agent budget, (7) return result or governance error. Map Iron Cage safety errors to standard MCP error codes: BudgetExceeded â†’ -32001, PiiDetected â†’ -32002, Unauthorized â†’ -32003, RateLimited â†’ -32004. Eliminate custom tool integration complexity (no hardcoded tool-specific logic per capability, agents discover tools dynamically instead of manual configuration, standard wire format enables ecosystem tool reuse) while preventing three critical failures of unrestricted tool access (budget exhaustion from runaway loops $100+ costs, PII leakage violating GDPR, unauthorized dangerous tool access rm -rf). Adhere to ID Format Standards (agent_<uuid> governance), Data Format Standards (ISO 8601 timestamps, decimal cost 2 decimals), Error Format Standards (machine-readable TOOL_NOT_FOUND/UNAUTHORIZED/BUDGET_EXCEEDED codes). Reference external Model Context Protocol specification (https://modelcontextprotocol.io) for JSON-RPC 2.0 base protocol |
| 005 | **005_budget_control_protocol.md** | Document budget enforcement and token management protocol (two-token system, budget borrowing, token handshake) |
| 006 | **006_token_management_api.md** | Define RESTful CRUD API for IC Token lifecycle management enabling developers and admins to create, list, view, delete, and rotate IC Tokens with permission-based access controls. Specify 5 HTTP endpoints: GET /api/v1/tokens (list with pagination ?page=N&per_page=M default 50 max 200, filters for project_id/status/agent_id, permission scoping: developers see own tokens, admins see all), GET /api/v1/tokens/{id} (detail with usage_summary showing total_requests and total_cost_usd, 403 Forbidden for unauthorized access), POST /api/v1/tokens (create with agent_id/project_id, returns token value ONLY on creation with warning message, enforces 1:1 agent-token constraint via 409 Conflict error), DELETE /api/v1/tokens/{id} (immediate invalidation with 204 No Content, causes budget protocol calls to return 401 Unauthorized), PUT /api/v1/tokens/{id}/rotate (atomic operation generating new value, invalidating old, returning new token with rotated_at timestamp). Authenticate all requests with User Token (not IC Token) to avoid circular dependency where IC Tokens manage themselves, mapping to CLI flow: iron login â†’ User Token â†’ iron tokens create. Enforce permissions every request: developers access only owned agent tokens via agent ownership check, admins unrestricted access, 403 Forbidden for unauthorized. Protect token values: only in POST/PUT responses, NEVER in GET/LIST endpoints, preventing credential leakage from logs or audit trails. Adhere to ID Format Standards (token_<uuid>), Data Format Standards (ISO 8601 timestamps, JSON booleans), Error Format Standards (machine-readable codes: VALIDATION_ERROR, UNAUTHORIZED, NOT_FOUND, DUPLICATE_NAME, PERMISSION_DENIED, RESOURCE_CONFLICT), API Design Standards (standard REST conventions). Map to CLI commands via features/004 (24 operations: iron tokens list/get/create/delete/rotate). |
| 007 | **007_authentication_api.md** | Define RESTful authentication API for User Token lifecycle management enabling developers, admins, and super users to authenticate to Control Panel via CLI and web dashboard. Specify 4 HTTP endpoints: POST /api/v1/auth/login (email/password â†’ User Token JWT signed with HS256, 30-day expiration 2592000 seconds, returns user object with role for permission enforcement, rate limited 5 attempts per 5 minutes per IP with account lockout after 10 failed attempts for dual-layer defense in depth, 3 error types: AUTH_INVALID_CREDENTIALS 401, AUTH_ACCOUNT_DISABLED 403, RATE_LIMIT_EXCEEDED 429 with retry_after/limit/window details), POST /api/v1/auth/logout (blacklist current User Token in redis/database checked on every authenticated request, 204 No Content, preserves other user tokens for multi-device support enabling simultaneous laptop CLI + desktop dashboard sessions), POST /api/v1/auth/refresh (generate new User Token with 30-day expiration, invalidate old token atomically eliminating race condition window, CLI auto-refreshes when < 7 days remaining transparently during any command, dashboard auto-refreshes every 24 hours while user active, AUTH_TOKEN_EXPIRED 401 if already expired), POST /api/v1/auth/validate (return 200 OK always with valid: true/false in body plus reason TOKEN_EXPIRED or TOKEN_REVOKED, used for pre-flight checks before batch operations). Authenticate with User Token (NOT IC Token which is for agents via Protocol 005) in Authorization: Bearer header to avoid circular dependency where IC Token management API (Protocol 006) requires User Token authentication preventing IC Tokens from managing themselves. Store CLI tokens encrypted in ~/.iron/credentials (AES-256), dashboard tokens in sessionStorage (HTTPS only, NEVER localStorage for XSS protection). JWT structure includes jti claim enabling selective revocation via blacklist while maintaining stateless verification for non-revoked tokens balancing performance (no database lookup for valid tokens) with security (blacklist checked for revoked tokens). Support multiple tokens per user tracked independently (logout only invalidates current token) enabling multi-device workflow. Adhere to ID Format Standards (user_<uuid>), Data Format Standards (ISO 8601 timestamps, 2592000 seconds integer for 30 days), Error Format Standards (AUTH_ prefix codes: AUTH_INVALID_CREDENTIALS, AUTH_TOKEN_EXPIRED, AUTH_INVALID_TOKEN, AUTH_ACCOUNT_DISABLED), API Design Standards (POST for all auth operations). Map to CLI commands: iron login/logout (explicit), iron auth status (validate), automatic refresh (transparent when < 7 days). |
| 008 | **008_user_management_api.md** | Define RESTful user management API for administrator user account lifecycle management enabling initial user provisioning, role-based access control administration, emergency access recovery, and complete audit trails for Iron Cage Control Panel team member management. Specify 8 Admin-only HTTP endpoints requiring ManageUsers permission: POST /api/v1/users (create with username/password/email/role, BCrypt cost factor 12, return 201 Created with numeric ID, validation: email contains @, password min 8 chars max 1000, role viewer/user/admin, errors: DUPLICATE_EMAIL, DUPLICATE_USERNAME), GET /api/v1/users (list with filters role/is_active/search, pagination page/page_size default 20 max 100, ordered by created_at DESC, include suspended_at/deleted_at as null when empty), GET /api/v1/users/{id} (retrieve by numeric ID, 200 OK with full user object, 404 Not Found if missing), PUT /api/v1/users/{id}/suspend (set is_active=0 suspended_at timestamp, require reason field, existing User Tokens remain valid until natural expiration), PUT /api/v1/users/{id}/activate (set is_active=1 clear suspended_at to NULL, user can authenticate again), DELETE /api/v1/users/{id} (soft delete: set deleted_at timestamp, reassign all owned agents to admin in "Orphaned Agents" special project proj_orphaned preserving IC Tokens and budgets for no service disruption, cancel pending budget requests with review_notes "Auto-cancelled: user deleted", revoke all API tokens, variable response format: return agents_affected array with full agent details when agents_count > 0 showing agent_id/name/new_owner_id/new_project_id/budget/providers, prevent self-deletion with 500 error, prevent last admin deletion with 400 error ensuring at least one admin exists), PUT /api/v1/users/{id}/role (change role to viewer/user/admin, existing User Tokens retain old role until reissued, prevent self-modification with 500 error), POST /api/v1/users/{id}/reset-password (admin sets new_password min 8 chars, optional force_change boolean requiring password update on next login via force_password_change flag, existing User Tokens remain valid not revoked). Authenticate all endpoints with User Token (JWT) in Authorization: Bearer header. Enforce Admin role with ManageUsers permission (403 Forbidden for non-admins). Implement soft deletion pattern (deleted_at timestamp, ON DELETE RESTRICT foreign keys, preserve audit trail). Log all operations in immutable user_audit_log table (operation/target_user_id/performed_by/timestamp/previous_state/new_state/reason). Adhere to ID Format Standards (numeric auto-incrementing user IDs via INTEGER PRIMARY KEY AUTOINCREMENT), Data Format Standards (Unix epoch millisecond timestamps as integers, JSON booleans true/false, null for empty timestamp fields), Error Format Standards (machine-readable codes: VALIDATION_ERROR, UNAUTHORIZED, FORBIDDEN, NOT_FOUND, DUPLICATE_EMAIL, DUPLICATE_USERNAME, SELF_MODIFICATION_FORBIDDEN, LAST_ADMIN_DELETION_FORBIDDEN), API Design Standards (pagination with page/page_size, filtering via query params, URL structure /api/v1/users and /api/v1/users/{id}, POST for creation 201 Created, PUT for updates 200 OK, DELETE for soft deletion 200 OK). Map to CLI commands via iron users create/list/get/suspend/activate/delete/set-role/reset-password with confirmation prompts for destructive operations and colorized output for status (active=green, suspended=yellow, deleted=red). |
| 010 | **010_agents_api.md** | Define RESTful agent management API for autonomous LLM entity lifecycle management enabling developers and admins to create, configure, monitor, and control agents consuming AI provider services within budget constraints. Specify 8 HTTP endpoints: POST /api/v1/agents (create with name/budget/providers/description/tags, automatic IC Token generation returned only once with save-now warning, 1:1 agent-budget RESTRICTIVE relationship, provider_id validation against available IP Tokens, return 201 Created with agent object including embedded ic_token object showing id/value/created_at), GET /api/v1/agents (list with pagination ?page=N&page_size=M default 50 max 200, filters agent_id/name/status/project_id, sorting created_at/name/budget/spent default created_at DESC, permission scoping: developers see owned agents, admins see all), GET /api/v1/agents/{id} (detail with full Agent Object showing 12 fields including owner_id/project_id/created_at/updated_at/tags plus nested ic_token object, 403 Forbidden for unauthorized, 404 Not Found), PUT /api/v1/agents/{id} (update name/description/tags only, budget modification via Protocol 013 Budget Limits API, provider assignments via dedicated endpoints, 200 OK with updated object), POST /api/v1/agents/{id}/providers (assign provider_id array, validate against available IP Tokens, idempotent with 200 OK already-assigned, audit log with previous/new states), GET /api/v1/agents/{id}/providers (list assigned providers returning array of provider_id strings, 200 OK, empty array when none), DELETE /api/v1/agents/{id}/providers/{provider_id} (remove single provider, 204 No Content, 404 if not assigned, prevent removal of last provider with 400 LAST_PROVIDER_REMOVAL), GET /api/v1/agents/{id}/status (runtime status with Agent Status Object showing budget_allocated/budget_spent/budget_remaining/provider_count/total_requests/last_active_at/uptime_seconds). Enforce owner-based access control (agent.owner_id === user.id for developers, admins unrestricted). Document 3 critical relationships: Agent â†” IC Token 1:1 (automatic generation on creation, Protocol 006 rotation, cascade delete), Agent â†” Agent Budget 1:1 RESTRICTIVE (clear ownership isolation, Protocol 005 enforcement via IC Token usage, Protocol 013 modification), Agent â†” Providers Many-to-Many (flexible provider selection, Protocol 011 provider management). Implement audit logging for 4 mutation operations (create/update/assign providers/remove provider with timestamp/user_id/action/resource_id/changes). Specify rate limiting (10 creates/hour per user, 100 updates/hour, 1000 reads/hour, admins unlimited). Adhere to ID Format Standards (agent_<alphanumeric> with regex ^agent_[a-z0-9]{6,32}$ for performance/readability/indexing, ic_<alphanumeric> with regex ^ic_[a-z0-9]{6,32}$, ip_<name>_<numeric> for IP Token identifiers, user_<uuid> and project_<uuid> for cross-system compatibility), Data Format Standards (ISO 8601 timestamps with Z suffix, decimal currency 2 decimals), Error Format Standards (machine-readable codes: VALIDATION_ERROR, AGENT_NOT_FOUND, AGENT_NAME_INVALID, BUDGET_INSUFFICIENT, PROVIDER_NOT_FOUND, PROVIDER_ALREADY_ASSIGNED, LAST_PROVIDER_REMOVAL, UNAUTHORIZED, FORBIDDEN). Map to CLI commands via iron agents create/list/get/update/status with automatic IC Token save to ~/.iron/credentials encrypted storage. Reference dependencies: Protocol 002 (REST standards), Protocol 005 (budget enforcement), Protocol 006 (IC Token management), Protocol 011 (provider management), Protocol 013 (budget limits). Used by Protocol 012 (Analytics API for spending analytics), Protocol 017 (Budget Requests API for budget change requests). Complement Protocol 005 two-token system where agent uses IC Token for LLM provider access while this API manages agent entity lifecycle |
| 011 | **011_providers_api.md** | Define RESTful provider management API for external AI service integration enabling admins to configure inference providers (OpenAI, Anthropic, etc.) with secure credential storage and developers to assign providers to agents for LLM access. Specify 8 HTTP endpoints: POST /api/v1/providers (create with name/endpoint/credentials/models, AES-256-GCM encryption at rest, credentials NEVER in responses, return 201 Created with ip_<name>_<numeric> identifier, admin-only), GET /api/v1/providers (list with pagination ?page=N&per_page=M default 50 max 100, filters name/status, sorting name/created_at, agent_count field showing assignment scale, any authenticated user), GET /api/v1/providers/{id} (detail with usage object showing agent_count/total_requests/total_spend/requests_today/spend_today for operational visibility, 200 OK), PUT /api/v1/providers/{id} (update name/endpoint/credentials/models, at least one field required, credential rotation replaces entirely preventing partial credential corruption, admin-only), DELETE /api/v1/providers/{id} (cascade deletion automatically removes from all agents via database-level CASCADE foreign key, return agents_affected array with impact details for audit compliance, 4 edge cases documented: single-provider agent left with zero providers, multi-provider agent continues working, in-flight requests fail gracefully, concurrent agent creation with deleted provider fails), PUT /api/v1/agents/{agent_id}/providers (assign provider_id array replacing complete list atomically, owner or admin, validation against available providers, audit log with previous/new provider assignments), GET /api/v1/agents/{agent_id}/providers (list with models array showing available LLM models per provider, owner or admin), DELETE /api/v1/agents/{agent_id}/providers/{provider_id} (remove single provider, owner or admin, prevent removal of last provider with 400 error ensuring agent always has LLM access). Document many-to-many agent-provider relationship enabling flexible provider selection (agents use multiple providers for redundancy, providers serve multiple agents for efficiency) with CASCADE delete behavior (database-level automation eliminating application logic complexity, automatic cleanup preventing orphaned assignments). Enforce security model: credentials encrypted at rest never in responses/logs preventing credential leakage, HTTPS required reject HTTP, admin-only provider CRUD separating system configuration from usage, owner-based provider assignment enabling distributed provider selection. Implement audit logging for 5 mutation operations (create/update/delete provider, assign/remove from agent with credentials EXCLUDED from logs for security). Specify rate limiting (10 creates/min, 60 reads/min, 30 updates/min, 10 deletes/min). Adhere to ID Format Standards (provider_id as ip_<name>_<numeric> with regex ^ip_[a-z0-9-]+_[0-9]{3}$ for operational clarity e.g. ip_openai_001, agent_id as agent_<alphanumeric> with regex ^agent_[a-z0-9]{6,32}$, user_<uuid> for cross-system compatibility), Data Format Standards (ISO 8601 timestamps, JSON booleans, empty arrays not null), Error Format Standards (machine-readable codes: VALIDATION_ERROR, NO_FIELDS_PROVIDED, FORBIDDEN, PROVIDER_NOT_FOUND, PROVIDER_NOT_ASSIGNED, PROVIDER_EXISTS, AGENT_NOT_FOUND), API Design Standards (pagination offset-based, filtering via query params, URL structure /api/v1/providers). Map to CLI commands via iron providers create/list/get/update/delete and iron agents assign-providers with confirmation prompts for deletion showing agent impact. Reference dependencies: Protocol 002 (REST standards), Protocol 010 (Agents API for agent-provider assignments). Used by Protocol 010 (agent-provider assignment endpoints), Protocol 012 (Analytics API for provider usage analytics). Complement Protocol 010 agent management with system-level provider integration configuration separating external service management (admin-controlled) from agent service selection (developer-controlled) |
| 012 | **012_analytics_api.md** | Define RESTful analytics API for LLM usage tracking enabling developers to monitor agent spending and budget status while admins aggregate cost analytics across all agents. Specify dual functionality: event ingestion (POST /api/v1/analytics/events with IC token auth from LlmRouter reporting completed/failed LLM requests using per-agent event_id deduplication via UNIQUE(agent_id, event_id) enabling idempotent retries, cost in microdollars 1 USD = 1,000,000 for precision, async processing 202 Accepted for non-blocking ingestion, rate limit 1000 events/min) and 8 query endpoints answering critical questions (GET /api/v1/analytics/spending/total for total spend, /spending/by-agent for per-agent breakdown with budget utilization percent_used, /budget/status for risk monitoring with levels low/medium/high/critical/exhausted, /spending/by-provider for cost attribution with avg_cost_per_request, /usage/requests for request count with success_rate, /usage/tokens/by-agent for token consumption with avg_tokens_per_request, /usage/models for model popularity with provider attribution, /spending/avg-per-request for capacity planning with median/min/max statistics). Implement period-based filtering across all queries (today, yesterday, last-7-days, last-30-days, all-time with UTC timezone), pagination (offset-based ?page=N&per_page=M default 50 max 100), filtering (agent_id, provider_id as query params), authorization model (users see own agents admins see all), rate limiting (20 queries/min protecting database from expensive analytics). Document performance targets (100ms-300ms response times with 30s query timeout returning 504, real-time calculation from live database with daily aggregation optimization, indexes on agent_id/provider_id/timestamp). Map to CLI commands via iron analytics spending total/by-agent/by-provider/avg-per-request, iron analytics usage requests/tokens/models, iron analytics budget status with period/agent/provider flags. Clarify distinction from /api/usage/* endpoints (simple project-level token tracking from UsageTracker vs /api/v1/analytics/* comprehensive event-based platform with budget monitoring, period filters, agent breakdowns using analytics_events table). Reference dependencies: Protocol 002 (REST standards), Protocol 005 (Budget Control for budget status queries), Protocol 010 (Agents API for agent entity), Protocol 011 (Providers API for provider entity). Adhere to ID Format Standards (provider_id as ip_<name>_<numeric> with regex ^ip_[a-z0-9-]+_[0-9]{3}$ for IP Token e.g. ip_openai_001, agent_id as agent_<alphanumeric> with regex ^agent_[a-z0-9]{6,32}$ for operational clarity), Data Format Standards (currency 2 decimal places, timestamps ISO 8601 with Z, date ranges as period enum), Error Format Standards (machine-readable codes VALIDATION_ERROR/UNAUTHORIZED/QUERY_TIMEOUT/RATE_LIMIT_EXCEEDED), API Design Standards (offset pagination, query param filtering, URL structure /api/v1/analytics/*) |
| 013 | **013_budget_limits_api.md** | Define RESTful HTTP API for modifying agent budgets after creation and viewing budget modification history. Specify admin-only budget modification (PUT /api/v1/limits/agents/{agent_id}/budget with budget/force/reason parameters) supporting full mutability (increase or decrease with force: true requirement for decreases preventing accidental agent shutdowns). Implement safety validation (budget decreases rejected without force flag showing impact analysis with current_spent and new_remaining_if_applied, budget unchanged validation, new budget >= 0.01 constraint). Document emergency use case for long-running agents approaching budget limits (admin bypasses Protocol 017: Budget Change Requests API request/approval workflow for immediate top-up, 95% budget usage scenario, critical 4-hour customer task). Specify budget history endpoint (GET /api/v1/limits/agents/{agent_id}/budget/history returning modification records sorted newest first with pagination page/per_page default 50 max 100, summary statistics initial_budget/current_budget/total_increases/modification_count). Define authorization model (admin can modify any agent budget and view any history, agent owner can view own agent history only, non-admin cannot modify directly must use Protocol 017 request workflow). Implement audit logging for all mutations (90-day retention, previous_budget/new_budget/reason/modified_by/timestamp, read operations not logged). Document force flag policy (asymmetric safety: increases safe/frictionless for emergency, decreases dangerous/require explicit confirmation with impact preview, first attempt rejected with detailed analysis, retry with force: true after review). Map to CLI commands (iron limits agent_budget increase/history/get with --reason flag, output showing previous/new/increase/remaining/modified_by/modified_at). Define error codes (VALIDATION_ERROR, BUDGET_DECREASE_REQUIRES_CONFIRMATION with impact fields, BUDGET_UNCHANGED, UNAUTHORIZED, TOKEN_EXPIRED, FORBIDDEN, AGENT_NOT_FOUND, RATE_LIMIT_EXCEEDED, INTERNAL_ERROR) and rate limiting (PUT 10 req/min, GET 60 req/min). Reference dependencies: Protocol 002 (REST standards), Protocol 005 (Budget Control for enforcement), Protocol 010 (Agents API for initial budget), Protocol 012 (Analytics for monitoring), Protocol 017 (Budget Change Requests for developer workflow). Document future enhancements (budget decrease support with admin approval workflow, budget alerts with threshold notifications, budget presets for quick increases). Adhere to ID Format Standards (agent_id as agent_<alphanumeric> with regex ^agent_[a-z0-9]{6,32}$, user_id as user_<alphanumeric> with regex ^user_[a-z0-9_]{3,32}$), Data Format Standards (currency 2 decimals, timestamps ISO 8601 with Z, booleans JSON true/false), Error Format Standards (machine-readable codes, consistent structure), API Design Standards (URL structure /api/v1/limits/*, PATCH method for modifications) |
| 018 | **018_keys_api.md** | Define RESTful API for AI provider key retrieval enabling users to fetch decrypted provider credentials for direct LLM access. Specify GET /api/v1/keys endpoint with API token authentication (user tokens only, agent tokens blocked with 403 Forbidden), provider key decryption (AES-GCM encrypted storage, CryptoService master key decryption), rate limiting (10 requests/minute per user/project), security enforcement (SHA-256 token verification, active/not-expired validation). Document error responses: 400 Bad Request (token not assigned to project), 401 Unauthorized (invalid/missing token), 403 Forbidden (agent token attempted access with Protocol 005 redirect), 404 Not Found (no provider key assigned), 429 Too Many Requests (rate limit exceeded), 500 Internal Server Error (decryption failed). Enforce critical security: agent tokens CANNOT use this endpoint to prevent budget control bypass - all agent LLM access MUST use Protocol 005 (Budget Control) budget handshake flow. Support use cases: developer testing (fetch OpenAI key for local scripts), dashboard direct access (test provider availability). Adhere to Token Format Standards (apitok_ prefix), Data Format Standards (JSON response), Error Format Standards (machine-readable error codes). Complement Protocol 005 (agent credential access with budget enforcement) with user credential access (no budget overhead for non-agent workflows) |

---

## Protocol Collection

### Certain Protocols (âœ… Required for Pilot)

| ID | Name | Purpose |
|----|------|---------|
| 002 | [REST API Protocol](002_rest_api_protocol.md) | HTTP REST API overview and common patterns |
| 003 | [WebSocket Protocol](003_websocket_protocol.md) | Real-time dashboard message format |
| 005 | [Budget Control Protocol](005_budget_control_protocol.md) | Two-token system (IC/IP), budget borrowing, token handshake |
| 006 | [Token Management API](006_token_management_api.md) | IC Token CRUD endpoints |
| 007 | [Authentication API](007_authentication_api.md) | User login/logout/refresh endpoints |
| 008 | [User Management API](008_user_management_api.md) | Admin user account management endpoints |
| 010 | [Agents API](010_agents_api.md) | Agent lifecycle management with IC Token and budget control |
| 011 | [Providers API](011_providers_api.md) | Provider CRUD and agent-provider assignments |
| 018 | [Keys API](018_keys_api.md) | AI provider key retrieval for user tokens |

### POST-PILOT Protocols (ðŸ“‹ Deferred Implementation)

| ID | Name | Purpose |
|----|------|---------|
| 004 | [MCP Integration Protocol](004_mcp_integration_protocol.md) | Model Context Protocol tool integration |
| 016 | [Settings API](016_settings_api.md) | System-wide configuration management |

---

## Cross-Collection Dependencies

**Protocols depend on:**
- **Capabilities:** Protocol implementations enable capabilities
- **Security:** Protocols follow security model
- **Architecture:** Protocols used in system architecture

**Protocols used by:**
- **Modules:** iron_control_api implements 002+003+006+007, iron_runtime uses 005, iron_cli uses 006+007
- **Architecture:** [architecture/004: Data Flow](../architecture/004_data_flow.md) uses budget control protocol (005)
- **Architecture:** [architecture/009: Resource Catalog](../architecture/009_resource_catalog.md) documents all REST API resources
- **Capabilities:** [capabilities/002: LLM Access Control](../capabilities/002_llm_access_control.md) enabled by budget protocol (005)
- **Features:** [features/004: Token Management CLI-API Parity](../features/004_token_management_cli_api_parity.md) uses 006+007

---

**Last Updated:** 2025-12-14
**Note:** Follows Design Collections format per documentation.rulebook.md Â§ protocol/ standards.
